```{r setup, include=FALSE}
opts_chunk$set(cache=TRUE)
```

Single-cell RNA-Seq Analysis
========================================================
author: Timothy Tickle and Brian Haas
css: single_cell_analysis.css
date: October 12, 2016

We Know Tissues are Complex
===

![complex](images/complex_tissues.png)

We can Separate Populations of Cells
===

<div align="center">
<img src="images/dropseq_paper.png" height=500>
</div>

We can Separate Populations of Cells
===

<div align="center">
<img src="images/dropseq_seperating_cells.png" height=500>
</div>

Heterogeneity can Help Describe Cell Type
===

<div align="center">
<img src="images/karthik_retina_paper.png" height=500>
</div>

Heterogeneity can Help Describe Cell Type
===

<div align="center">
<img src="images/shekhar_cell_type.png" height=500>
</div>

Heterogeneity can Describe Phenotypes
===

<div align="center">
<img src="images/itay_paper.png" height=500>
</div>

Heterogeneity can Describe Phenotypes
===

<div align="center">
<img src="images/single_cell_clinical.png" height=500>
</div>

Before We Get Started
===

- Single-cell RNA-Seq analysis is developing.
  - Give you a feel for the data.
  - Walk different analysis in a couple data sets.
- There is a vivid diversity of methodology
  - These techniques will grow as the field does.
  - Why these tools were chosen.
- This is a guided conversation through scRNA-Seq Analysis
  - Breadth and targeted depth
  - If you have expertise to add, let's have that conversation!

Before We Get Started
===

- This is VERY hands-on.
  - Much can be applied to other analyses.
  - Strengthen those R ninja skills!
  - If you need, cut and pasting is available (cut_and_paste.txt).
  - There will many cute corgi pictures.

---

![ninja corgis](images/corgis/ninja_corgi.jpeg)

What We Will Attempt to Cover
===

### Section 1  
__Part 1:__ Overview of laboratory prep and sequence analysis.  
__Part 2:__ Characteristics of expression data and QC.  

### Section 2  
__Part 1:__ Plotting Single Cell RNA-Seq data.  
__Part 2:__ Evaluating and defining cell populations.  

Welcome to Section 1
===

- Overview of assays (SmartSeq2, Dropseq, 10X).
- Overview of sequence data (SmartSeq2, Dropseq, 10X).
- Overview of Dropseq sequence analysis pipeline.
- Overview of 10X sequence analysis pipeline.
- Sequence level quality control.
- What does single cell expression data look like and why?
- Introduction to RStudio.
- Initial data exploration.
- Quality control for expression matrices.
- Filtering genes and cells.
- Data analysis using UMIs.

Overview of assays
===

<div align="center">
<img src="images/corgis/scientist.jpg" height=500>
</div>

SmartSeq2
===
  
![smartseq_paper](images/smartseq_paper.png)

---

![smartseq_protocols](images/smartseq_protocols.png)

SmartSeq2: Description
===

- Developed for single cell but can performed using total RNA.
- Selects for poly-A tail.
- Full transcript assay.
  - Uses template switching for 5' end capture.
- Standard illumina sequencing.
  - Off-the-shelf products.
- Hundreds of samples.
- Often do not see UMI used.

SmartSeq2: Assay Overview
===

<div> 
<img src="images/smart_seq2.png" height=400>
</div>

---

- Poly-A capture with 30nt polyT and 25nt 5' anchor sequence.
- RT adding untemplated C
- Template switching
  - Locked Nucleic Acid binds to untemplated C
  - RT switches template
- Preamplification / cleanup
- DNA fragmentation and adapter ligation together.
- Gap Repair, enrich, purify

SmartSeq2: Equipment
===

![sequencer](images/nextseq-large.jpg)

---

![plate](images/plate.jpg)

Dropseq
===

<div>
<img src="images/dropseq_paper.png" height=500>
</div>

Dropseq: Description
===

- Moved throughput from hundreds to thousands.
- Droplet-based processing using microfluidics
  - Nanoliter scale aqueous drops in oil.
  - 3' End
- Bead based (STAMPs).
  - Single-cell transcriptomes attached to microparticles.
  - Cell barcodes use split-pool synthesis.
- Uses UMI (Unique Molecular Identifier).
  - RMT (Random Molecular Tag).
  - Degenerate synthesis.

Dropseq: Assay Overview
===

[Click Here for Dropseq Video Abstract](http://www.sciencedirect.com/science/article/pii/S0092867415005498)

Dropseq: Assay and UMI Construction
===

![drop_umi](images/dropseq_assay_umi.png)   
Macosko et al. 2015

Dropseq: Sequencing Overview
===

<div>
<img src="images/dropseq_assay_1.png" height=500>
</div>

Dropseq: Microfluidics
===

![drop_beads](images/dropseq_drops.gif)

Dropseq: Equipment
===

![dropseq_eq](images/dropseq_equipment.png)

Dropseq: Pointers
===

- Droplet-based assays can have leaky RNA.
- Before library generation wash off any medium (inhibits library generation).
- Adding PBS and BSA (0.05-0.01%) can protect the cell.
  - Too much produces a residue making harvesting the beads difficult.
- Filter all reagent with a 80 micron strainer before microfluidics.
- Some purchased devices add a hydrophobic coating.
  - Can deteriorate (2 months at best).
  - Recoating does work (in-house).

10X: Massively Parallel Sequencing
===

<div>
<img src="images/10X_paper.png" height=500>
</div>

10X: Description
===

- Droplet-based, 3' mRNA.
  - GEM (Gel Bead in Emulsion)
- Standardized instrumentation and reagents.
- More high-throughput scaling to tens of thousands.
- Less processing time.
- Up to 50% capture rate.
- Cell Ranger software is available for install.

10X: Assay Overview
===

![10x_assay](images/10X_wet.png)   
Zheng et al.

10X: Sequences
===

![10x_sequence](images/10X_wet_mol.png)

- 14nt barcode, 10nt UMI, 30nt polyT + sequencing adaptor and primers.

10X: Equipment
===

![10x_gem](images/10X_gem.png)

---

![10x_chip](images/dropseq_fluidics_big.png)

Comparing Assays
===

<div>
<img src="images/compare_power_paper.png" height=500>
</div>

Comparing Assays
===

Based on ERCC spike-ins.   

**Accuracy:** How well the abundance levels correlated with known spiked-in amounts.   

**Sensitivity:** Minimum number of input RNA molecules required to detect a spike-in.   

Comparing Assays
===

Svensson et al. 2016
<div>
<img src="images/compare_assays.png" height=500>
</div>

Comparing Assays
===

- Different assays have different throughput.
  - SmartSeq2 < Dropseq < 10X
- SmartSeq2 is full transcript.
- Plate-based methods get lysed in wells and so do not leak.
  - Droplet-based can have leaky RNA.
- In Dropseq assays RT happens outside the droplets
  - Can use harsher lysis buffers.
  - 10X needs lysis buffers compatible with the RT enzyme.
- 10X is more standardized and comes with a pipeline.
  - Dropseq is more customizable but more hands-on.
- Cost per library varies greatly.

A Word on Sorting
===

- After disassociating cells cells can be performed.
- Know your cells, are they sticky, are they big?
  - Select an appropriate sized nozzle.
- Don't sort too quickly (1-2k cells per second or lower)
  - the slower the more time cells sit in lysis after sorting
    - 10 minutes max in lysis (some say 30 minutes)
- Calibrate speed of instrument with beads
  - Check alignment every 5-6 plates
- Afterwards spin down to make sure cells are in lysis buffer
  - Flash freeze
- Chloe Villani on sorting https://youtu.be/HiKY0eHDhIs

Sequence Pipeline Overviews
===

![corgi_can](images/corgis/corgi_can.jpg)

Starting Sequences
===

<div align="center">
<img src="images/fastq.png" height=500>
</div>

Assays have Different Formats
===

![fastq_seq](images/sc_sequences.png)

Smartseq2: Pipeline Overview
===

![smart_seq_seq](images/population_rnaseq.png)

Dropseq: Pipeline Overview
===

![drop_seq_seq](images/dropseq_rnaseq.png)

---

- Common functionality: trimming, alignment, generating count matrix.
- Adds book keeping for cell barcodes and UMIs, bead error detection, cell barcode collapsing, UMI collapsing.

Dropseq: Further Help
===

![drop_seq_web](images/drop_seq_web.png)

10X: Pipeline Overview
===

![10_seq](images/10x_rnaseq.png)

---

- Steps very similar to the Dropseq pipeline.

10X: Further Help
===

![10_help](images/10x_web.png)

Sequence Level Quality Control
===

![seq_qc](images/population_rnaseq_qc.png)

---

- Much of the QC that is performed is using traditional tools.

Section Summary
===

- Single-cell RNA-Seq is a diverse ecosystem of assays.
  - Each assay has pros and cons.
- Sequences derived from these assays are complex and vary.
- Different pipelines are needed to address different sequence formats.
  - Common steps like aligning, QC, and reads counting are in common.

Let's Describe scRNA-Seq Count Data
===

![driving](images/corgis/driving_corgi.jpg)

We Start with a Matrix of Expression
===

![starting_matrix](images/starting_matrix.png)

Genes Have Different Distributions
===
class:small-code

![genes_log_normal](images/scdistributions_log_normal.png)

Genes Have Different Distributions
===
class:small-code

![genes_bimodal](images/scdistributions_bimodal.png)

Genes Have Different Distributions
===
class:small-code

![genes_zeroinfl](images/scdistributions_zeroinfl.png)

Genes Have Different Distributions
===
class:small-code

![genes_noise](images/scdistributions_noise.png)

Genes Have Different Distributions
===
class:small-code

![professor corgi](images/scdistributions_all.png)

Underlying Biology
===

Zero inflation.
- Drop-out event during reverse-transcription.
- Genes with more expression have less zeros.
- Complexity varies.

Transcription stochasticity.
- Transcription bursting.
- Coordinated transcription of multigene networks.
- Overdispersed counts.

Higher Resolution.
- More sources of signal
  - Cell cycle

---

![scde_bio](images/scde_bio.png)  
Karchenko et al.

Data analysis when using UMIs
===

**Read Counts**
 
![reads](images/reads.png)

---

 **Counts by UMIs**
 
![umi](images/umi.png)

Summary of the Data
===

- We are still understanding scData and how to apply it.
  - Data can be NOT normal.
  - Data can be Zero-inflated.
  - Data can be very noisy.
  - Cells vary in library complexity.
- Keeping these characteristics in analysis assumptions.
- Trend to filter more conservatively with UMIs.

Introduction to RStudio
===

![bed](images/corgis/dogbutt.jpg)

Motivation: Why Am I Using R?
===

- A lot of method development is happening in R.
- Free / open source / open science.
- Many supplemental computational biology packages.
- Data science is an art.
  - Data often requires one to create and manipulate analysis.
- This will allow you to experience key concepts in analysis.

RStudio (IDE)
===

![rstudio_overview](images/Rstudio_overview.png)

Initial data exploration
===

![professor corgi](images/corgis/professor_corgi.jpg)

Seurat
===

![suerat](images/seurat_pubs.png)

Seurat: Today's Data
===

- Using data provided by 10X (2700 cells).
- Peripheral blood mononuclear cells (PBMCs).
  - Any peripheral blood cell with a round nucleus.
  - Lymphocytes (T cells, B cells, NK cells)
  - Monocytes
- Complex mix cell populations used in immunity.

Logistics
===
class:small-code

- R allows methodology written by others to be imported.
  - Leverage other code.
  - Make your code available to others.  

```{r, eval=TRUE, echo=TRUE, tidy=FALSE}
# Load libraries
library(dplyr) # Dataframe manipulation
library(Matrix) # Sparse matrices
library(useful) # Corner function
library(vioplot) # Violin pots
library(scater) # Single Cell QC
library(scde) # Differential Expression
library(org.Hs.eg.db) # Gene name manipulation
library(Seurat) # Single cell General Analysis
```

Representing Sparse Matrices
===

```{r, eval=TRUE, echo=TRUE, tidy=FALSE}
# Load 10X data
pbmc.10X <- Read10X("./data/filtered_gene_bc_matrices/hg19")

# Memory use as a sparse matrix
object.size(pbmc.10X)

# Memory use as a dense matrix
# 18 X more
object.size(as.matrix(pbmc.10X))
```

How are Sparse Representations Made?
===

- Sparse Matrix: A matrix where most of the elements are 0.
- Dense Matrix: A matrix where most elements are not 0.
- In this case, underlying data structure is a coordinate list.

2D Arrays vs Coordinate List
===

![sparse](images/sparseMatrices.png)

Create a Seurat Object
===

```{r, eval=TRUE, echo=TRUE, tidy=FALSE}
# Expected raw counts (non-normalized data)
# Can give log transformed data but do not transform in setup method
pbmc.seurat <- new("seurat", raw.data=pbmc.10X)
```

What is in a Seurat Object?
===

```{r, eval=TRUE, echo=TRUE, tidy=FALSE}
# Display the internal pieces of the Seurat Object
slotNames(pbmc.seurat)
```

What is in a Seurat Object?
===

```{r, eval=TRUE, echo=FALSE, tidy=FALSE}
# Display the internal pieces of the Seurat Object
slotNames(pbmc.seurat)
```

What is in a Seurat Object?
===

Raw sparse matrix

```{r, eval=TRUE, echo=TRUE, tidy=FALSE}
head(pbmc.seurat@raw.data)
```

What is in a Seurat Object?
===

- __var.genes__ Variable genes across cells
- __data.info__ Misc info including complexity (nGene) 
- __cell.names__ Column (cell) names 
- __gene.names__ Row (gene) names

```{r, eval=FALSE, echo=TRUE, tidy=FALSE}
?seurat
```

Always Look at Your Data
===
class:midcenter

_**Hiding within those mounds of data is knowledge that could change the life of a patient, or change the world.**_  -â€“ Atul Butte

What are Our Genes?
===
class:small-code

```{r,eval=TRUE, echo=TRUE,tidy=TRUE}
# Gene names (row names)
head(row.names(pbmc.seurat@raw.data))
length(row.names(pbmc.seurat@raw.data))
```

What are Our Cells?
===
class:small-code

```{r,eval=TRUE, echo=TRUE,tidy=FALSE}
# Column names
# Sample / Cell names / Barcodes
head(colnames(pbmc.seurat@raw.data))
length(colnames(pbmc.seurat@raw.data))
```

How to Show Counts?
===
class:small-code

```{r,eval=FALSE, echo=TRUE,tidy=FALSE}
# Only the corner
# The full data will be too large to see
corner(as.matrix(pbmc.seurat@raw.data))
```

How to Show Counts?
===
class:small-code

```{r,eval=TRUE, echo=FALSE,tidy=FALSE}
# Only the corner
# The full data will be too large to see
corner(as.matrix(pbmc.seurat@raw.data))
```

Complexity of Libraries
===

- Very important metadata.
- How many genes had a count of more than 1 in a cell.
  - Simplest, most common definition.

How Many Expressed Genes?
===
class:small-code

```{r, eval=TRUE, echo=TRUE, tidy=TRUE}
# Plot genes per cell
# How many genes expressed per cells
complexity.per.cell <- apply(pbmc.seurat@raw.data, 2, function(x) sum(x>0))
# Mean count per cell.
mean.count.per.cell <- apply(pbmc.seurat@raw.data, 2, function(x) mean(x))
# Gene prevalence
gene.prevalence <- apply(pbmc.seurat@raw.data, 1, function(x) sum(x>0))
```

How Many Expressed Genes?
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
# Plot genes per cell
# How many genes expressed per cell
vioplot(complexity.per.cell)
stripchart(complexity.per.cell, add=TRUE, vertical=TRUE, method="jitter", jitter=0.3, pch=19)
abline(h=200, col="red")
abline(h=2500, col="blue")
title("Study Complexity")
axis(side=1,at=1,labels=c("Study"))
```

How Many Expressed Genes?
===
class:small-code

```{r, eval=TRUE, echo=FALSE, tidy=TRUE}
# Plot genes per cell
# How many genes expressed per cell
vioplot(complexity.per.cell)
stripchart(complexity.per.cell, add=TRUE, vertical=TRUE, method="jitter", jitter=0.3, pch=19)
abline(h=200, col="red")
abline(h=2500, col="blue")
title("Study Complexity")
axis(side=1,at=1,labels=c("Study"))
```

---

- Shown complexity of all cells in a study. 
- Wide range of complexity.
- Prefiltered data at red line.
- Will define points about the blue line as outlier.

Box Plots vs Violin Plots
===
class:small-code

**Boxplot:**  
Robust representation of a distribution using quantiles

```{r, eval=TRUE, echo=FALSE, tidy=TRUE}
boxplot(complexity.per.cell)
title("Study Complexity")
axis(side=1,at=1,labels=c("Study"))
```

---

**Violin Plot:**  
Box plot with kernel density plot mirrored on sides.

```{r, eval=TRUE, echo=FALSE, tidy=TRUE}
vioplot(complexity.per.cell)
title("Study Complexity")
axis(side=1,at=1,labels=c("Study"))
```

Identifying Outliers?
===
class:small-code

- Cells that are unusually simple (or no counts)
- Cells that are unusually complex (doublets?)

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
plot(complexity.per.cell,mean.count.per.cell+1)
abline(v=200, col="red")
abline(h=log2(4))
```

Identifying Outliers?
===
class:small-code

- We will filter in a standard way, we are just describing the data.
- Red line shows a point of prefiltering.

```{r, eval=TRUE, echo=FALSE, tidy=TRUE}
plot(complexity.per.cell,mean.count.per.cell+1)
abline(v=200, col="red")
abline(h=log2(4))
```

Identifying Noise?
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
#hist(gene.prevalence)
hist(log2(gene.prevalence))
abline(v=3, col="red")
```

Identifying Noise?
===
class:small-code

- People tend to filter very conservatively.
- 3 is where we will filter (red line).

```{r, eval=TRUE, echo=FALSE, tidy=TRUE}
#hist(gene.prevalence)
hist(log2(gene.prevalence))
abline(v=3, col="red")
```

Filter Cells: Removing the Outlier Cells
===
class:small-code

- Genes must be in 3 cells with alteast 200 genes.
- Scaled by 1000 (Total Sum Scaling)
```{r, eval=TRUE, echo=TRUE, tidy=TRUE}
pbmc.seurat <- Setup(pbmc.seurat,
                    min.cells=3, min.genes=200,
                    do.logNormalize=TRUE,
                    total.expr=1e4,
                    project="Tutorial")
```

Expression: Definition
===

**Population based RNA-Seq**
- Different ways to move from counts to expression.
- EM algorithms (RSEM)
- TPM with TMM normalization.
  - Control for transcript length and force the depth to be 10^6.
  - Trimmed means weighted focusing on invariant genes through samples.

**Today we are using**
- log2( ( cell_counts / cell_sum ) * 1000 + 1 )
- Account for sequencing depth.

Filter Genes: Averages are Less Useful
===
class:small-code

_**Say you were standing with one foot in the oven and one foot in an ice bucket. According to the percentage people, you should be perfectly comfortable.**_ --Bobby Bragan

Filter Genes: Averages are Less Useful
===
class:small-code

![average](images/prob_ave_expression.png)

Filter Genes: Using Prevalence
===

**Filtering with gene prevalence:**   
How many times a gene's count is greater than or equal to an expression threshold throughout cells.

![prevalence](images/prevalence.png)

Filter Genes: Using Prevalence
===
class:small-code

![occurence](images/prob_ave_expression2.png)

Filtering Using Metadata
===

![puppies](images/corgis/puppies.jpg)

What is Metadata?
===

Other information that describes your measurements.
- Patient information.
  - Life style (smoking), Patient Biology (age), Comorbidity
- Study information.
  - Treatment, Cage, Sequencing Site, Sequencing Date
- Sequence QC on cells.
  - Useful in filtering.

Filter Cells: Removing the Outlier Cells
===
class:small-code

- Outlier cells are not just measured by complexity
  - **Useful Metrics**
     - Percent Reads Mapping
     - Percent Mitochondrial Reads
     - Presence of marker genes
     - Intergenic/ exonic rate
     - 5' or 3' bias
     - other metadata ...
  - **Useful Tools**
     - Picard Tools and RNASeQC

Seurat: Filtering on Metadata
===
class:small-code

- Filtering on mitochondrial reads in Seurat.  
```{r, echo=TRUE, eval=TRUE}
# Get gene names
mito.gene.names <- grep("^MT-", rownames(pbmc.seurat@data), value=TRUE)

# Get TSS normalized mitochodrial counts
col.total.counts <- Matrix::colSums(expm1(pbmc.seurat@data))
mito.percent.counts <- Matrix::colSums(expm1(pbmc.seurat@data[mito.gene.names, ]))/col.total.counts

# Add to seurat object as a metadata
pbmc.seurat <- AddMetaData(pbmc.seurat, mito.percent.counts, "percent.mitochodrial")
```

Seurat: Filtering on Metadata
===
class:small-code

- Plot current metadata in Seurat Object.
 - Number gene.
 - Number UMI.
 - Percent mitochondrial counts.
 
```{r, eval=FALSE, echo=FALSE,}
VlnPlot(pbmc.seurat, c("nGene", "nUMI", "percent.mitochodrial"), nCol=3)
```

Seurat: Filtering on Metadata
===
class:small-code

```{r,  eval=TRUE, echo=FALSE}
VlnPlot(pbmc.seurat, c("nGene", "nUMI", "percent.mitochodrial"), nCol=3)
```

Seurat: Filtering on Metadata
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
GenePlot(pbmc.seurat, "nUMI", "percent.mitochodrial")
```

Seurat: Filtering on Metadata
===
class:small-code

- Outlier percent mitochondria are very low expression.
- Very high expression low percent mitochondrial reads.

```{r, eval=TRUE, echo=FALSE}
GenePlot(pbmc.seurat, "nUMI", "percent.mitochodrial")
```

Seurat: Filtering on Metadata
===
class:small-code

```{r,  eval=TRUE, echo=FALSE}
GenePlot(pbmc.seurat, "nUMI", "nGene")
```

Seurat: Filtering on Metadata
===
class:small-code

```{r, eval=TRUE, echo=TRUE}
dim(pbmc.seurat@data)
pbmc.seurat <- SubsetData(pbmc.seurat, subset.name = "nGene", accept.high = 2500)
pbmc.seurat <- SubsetData(pbmc.seurat, subset.name = "percent.mitochodrial", accept.high = 0.05)
dim(pbmc.seurat@data)
```

Saving as an R Object
===
class:small-code

Saving the Seurat object
- Contains all manipulation so far.
- Can be loaded or shared.
- Does not contain environment.

```{r, eval=FALSE, echo=TRUE}
# How to save the intact object.
save(pbmc.seurat, file = "seurat_tutorial.Robj")
```
```{r, eval=FALSE, echo=TRUE}
# How to retrieve the intact object.
load("seurat_tutorial.Robj")
```

Saving as Text Files
===

You may need to export data to import into other applications.

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
# Log-scale expression matrix
write.table(as.matrix(pbmc.seurat@data), file="seurat_data.txt")

# Study metadata
write.table(pbmc.seurat@data.info, file="seurat_metadata.txt")

# What is the metadata so far
head(pbmc.seurat@data.info)
```

Scater: Complex QC Plotting
===

![scater_paper](images/scater_paper.png)

Scater: Motivation
===

- Clinical studies are often rich with metadata.
- Most differential expression methodology is T-test.
  - Much like using covariates in linear regression to control here we stratify by metadata to describe the impact of the metadatum.
- More than what we are covering here.
- Online tutorial [Click Here](//bioconductor.org/packages/devel/bioc/vignettes/scater/inst/doc/vignette.html)

Scater: Skipping Ahead
===
class:small-code

```{r,  eval=TRUE, echo=TRUE}
# Load Data
data("sc_example_counts")
data("sc_example_cell_info")
pd <- new("AnnotatedDataFrame", data=sc_example_cell_info)
rownames(pd) <- pd$Cell
example_sceset <- newSCESet(countData=sc_example_counts, phenoData=pd)
keep_feature <- rowSums(exprs(example_sceset)) > 0
example_sceset <- example_sceset[keep_feature,]
example_sceset <- calculateQCMetrics(example_sceset, feature_controls = 1:40)
```

Scater: Describe the Data
===

Small data set of 40 cells.
- Constructed metadata
- Metadata including
  - Mutation status (positive, negative)
  - Cell Cycle (S, G0, G1, G2M)
  - Treament (treat1, treat2)

Scater: What is the Data?
===
class:small-code

```{r, eval=TRUE, echo=TRUE}
corner(sc_example_counts)
```

Scater: What is the info?
===
class:small-code

```{r, eval=TRUE, echo=TRUE}
corner(sc_example_cell_info)
```

Scater: Stratifying for Metadata
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
plot(example_sceset, block1 = "Mutation_Status", block2 = "Treatment",
     colour_by = "Cell_Cycle", nfeatures = 300, exprs_values = "counts")
```

Scater: Stratifying for Metadata
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
plot(example_sceset, block1 = "Mutation_Status", block2 = "Treatment",
     colour_by = "Cell_Cycle", nfeatures = 300, exprs_values = "counts")
```

Scater: Stratifying for Metadata
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
plotExpression(example_sceset, rownames(example_sceset)[1:6],
               x = "Mutation_Status", exprs_values = "exprs", colour = "Treatment")
```

Scater: Stratifying for Metadata
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
plotExpression(example_sceset, rownames(example_sceset)[1:6],
               x = "Mutation_Status", exprs_values = "exprs", colour = "Treatment")
```

Scater: Interactive Exploration
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
scater_gui(example_sceset)
```

Section Summary
===

- scRNA-Seq is complex and can NOT be treated as population based measurements.
- Cell complexity is an important metadatum for QC.
- Conservative gene filtering based on gene count and prevalence is often used.
- Cells can be filtered by complexity and also other metadatum.

Where are we at?
===

We have now
- Loaded in data into R.
- Explored and plotted the data for QC.
- Filtered on counts and metadata.

Next
- Focus on plotting Genes and Cells.
- View cell groups to later use in DE.

Let's Get Started!
===

<div align="center">
<img src="images/corgis/pillows.jpg" height=500>
</div>

Welcome to section 2!
===

- Using Seurat to plot genes
- Batch effects and study confounding
- Dimensionality reduction and plotting (PCA, t-SNE).
- Plotting cells.
- Moving from clusters to populations of cells.
- Differential Expression (SCDE).
- Pathway analysis.
- Overview of available methodology.

Using Seurat to plot genes
===

![tea](images/corgis/tea.jpg)

Seurat: Viewing Specific Genes
===
class:small-code

- Check the identity of the cells!!!
- Notice many zeros.

```{r,eval=FALSE, echo=TRUE,tidy=TRUE,fig.align="center"}
VlnPlot(pbmc.seurat, c("GAPDH"))
```

Seurat: Viewing Specific Genes
===
class:small-code

- Check the identity of the cells!!!
- Notice many zeros.

```{r,eval=TRUE, echo=FALSE,tidy=TRUE,fig.align="center"}
VlnPlot(pbmc.seurat, c("GAPDH"))
```

Seurat: Plotting Genes vs Genes
===
class:small-code

```{r,eval=FALSE, echo=TRUE,tidy=TRUE,fig.align="center"}
# Plot a gene vs a gene
GenePlot(pbmc.seurat,"CD79A","CD79B",cex.use=1)
```

Seurat: Plotting Genes vs Genes
===
class:small-code

```{r,eval=TRUE, echo=TRUE,tidy=TRUE,fig.align="center"}
GenePlot(pbmc.seurat,"CD79A","CD79B",cex.use=1)
```

Single Cell RNA-Seq and Batch Affects
===

![fall](images/corgis/fall.jpg)

Single Cell RNA-Seq and Batch Affects
===

![confounding_paper](images/confounding_paper.png)

What is Confounding?
===

<div align="center">
<img src="images/confounding.png" height=500>
</div>

Confounding by Design
===

![batch_effects](images/batch_effects_4.png)

Normalization and Batch Affect Correction
===

- The nature of scRNA-Seq assays can make them prone to confounding with batch affects.
  - Normalization and batch affect correction can help.
- Some are moving away from relying on a specific method.
  - Exploring the idea of combining or selecting from a collection of normalization or correction methods best for a specific study.
- Some believe UMI based analysis need not be normalized between samples given the absolute count of the molecules are being reported.
  - Be careful not to remove biological signal with good experimental design (avoiding confounding by design).

Seurat and Batch Affect Correction
===

- Using linear models one can regress covariates.
  - scale.data hold the residuals after regressing (z-scored)
- Dimensionality reduction and clustering.
- We use metadata we have.
  - One could imagine creating a metadata for cell cycle.

Seurat and Batch Affect Correction
===
class:small-code

```{r, eval=TRUE, echo=TRUE}
pbmc.seurat <- RegressOut(pbmc.seurat, latent.vars = c("nUMI", "percent.mitochodrial"))
```

Scone: Data
===

- 65 human cells
  - Cultured neural progenitor cells ("NPC") from pluripotent stem cells.
  - Primary cortical samples at 16 and 21 gestation weeks.
    - 21 gestation weeks then cultered for 3 weeks.
- Pollen et al 2014

Scone: Batch Correction
===
class:small-code

```{r, eval=TRUE, echo=TRUE}
set.seed(6473)
library(scone)
library(RColorBrewer)
library(scRNAseq)
data(fluidigm)
# Set assay to RSEM estimated counts
assay(fluidigm) = assays(fluidigm)$rsem_counts
```

Scone: Which Metadata?
===
class:small-code

- Which metadata are we using?

```{r, eval=FALSE, echo=TRUE}
metadata(fluidigm)$which_qc
```

Scone: Which Metadata?
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
metadata(fluidigm)$which_qc
```

Scone: Accessing Metadata
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
head(colData(fluidigm))
head(colData(fluidigm)$Coverage_Type)
```

Scone: Logistics
===
class:small-code

- Cells were sequenced twice.
- Removing low coverage replicates.
- Removing undetected genes.

```{r, eval=TRUE, echo=TRUE}
# Preliminary Sample Filtering: High-Coverage Only
is_select = colData(fluidigm)$Coverage_Type == "High" 
fluidigm = fluidigm[,is_select]
# Retain only detected transcripts
fluidigm = fluidigm[which(apply(assay(fluidigm) > 0,1,any)),]
```

Scone: Batches
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
# Viz only
# Define a color scheme
cc <- c(brewer.pal(9, "Set1"))

# One batch per Biological Condition
batch = factor(colData(fluidigm)$Biological_Condition)

# Alignment Quality Metrics
qc = colData(fluidigm)[,metadata(fluidigm)$which_qc]

# Barplot of read proportion mapping to human transcriptome
ralign = qc$RALIGN
o = order(ralign)[order(batch[order(ralign)])] # Order by batch, then value

barplot(ralign[o], col=cc[batch][o], border=cc[batch][o], main="Percentage of reads mapped")
legend("bottomleft", legend=levels(batch), fill=cc,cex=0.4)
```

Scone: Batches
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
# Viz only
# Barplot of total read number
nreads = qc$NREADS
o = order(nreads)[order(batch[order(nreads)])] # Order by batch, then value
barplot(nreads[o], col=cc[batch][o], border=cc[batch][o], main="Total number of reads")
legend("topright", legend=levels(batch), fill=cc, cex=0.4)
```

Scone: Related Metrics
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
qpc = prcomp(qc,center = TRUE,scale. = TRUE)
barplot((qpc$sdev^2)/sum(qpc$sdev^2), border="gray", xlab="PC", ylab="Proportion of Variance", main="Quality PCA")
```

Scone: Strongest Signal
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
# Barplot of PC1 of the QC matrix
qc1 = as.vector(qpc$x[,1])
o = order(qc1)[order(batch[order(qc1)])]
barplot(qc1[o], col=cc[batch][o], border=cc[batch][o], main="Quality PC1")
legend("bottomright", legend=levels(batch), fill=cc, cex=0.8)
```

Scone: Filtering
===
class:small-code

- Filtering on prevalance at a certain level of expression.

```{r, eval=TRUE, echo=TRUE}
# Initial Gene Filtering: Select "common" transcripts based on proportional criteria.
num_reads = quantile(assay(fluidigm)[assay(fluidigm) > 0])[4]
num_cells = 0.25*ncol(fluidigm)
is_common = rowSums(assay(fluidigm) >= num_reads ) >= num_cells
```

Scone: Filtering
===
class:small-code

- We will be pulling in house keeping genes for the filtering.

```{r, eval=TRUE, echo=TRUE}
data(housekeeping)
hk = intersect(housekeeping$V1,rownames(assay(fluidigm)))
head(housekeeping$V1)
```

Scone: Filtering
===
class:small-code

```{r, eval=TRUE, echo=TRUE}
# Metric-based Filtering
mfilt = metric_sample_filter(assay(fluidigm), 
          nreads=colData(fluidigm)$NREADS,
          ralign=colData(fluidigm)$RALIGN,
          gene_filter=is_common,
          pos_controls=rownames(fluidigm) %in% hk,
          zcut=3, mixture=FALSE, 
          plot=FALSE)
```

Scone: Filtering
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
# VIZ only
hist(qc$RALIGN, breaks = 0:100)
# Hard threshold
abline(v = 15, col = "yellow", lwd = 2) 
# 3 (zcut) standard deviations below the mean ralign value
abline(v = mean(qc$RALIGN) - 3*sd(qc$RALIGN), col = "green", lwd = 2) 
# 3 (zcut) MADs below the median ralign value
abline(v = median(qc$RALIGN) - 3*mad(qc$RALIGN), col = "red", lwd = 2)
# Sufficient threshold
abline(v = NULL, col = "grey", lwd = 2)
# Final threshold is the minimum of 1) the sufficient threshold and 2) the max of all others
thresh = min(NULL,max(c(15,mean(qc$RALIGN) - 3*sd(qc$RALIGN),median(qc$RALIGN) - 3*mad(qc$RALIGN))))
abline(v = thresh, col = "blue", lwd = 2, lty = 2)
legend("topleft",legend = c("Hard","SD","MAD","Sufficient","Final"),lwd = 2, col = c("yellow","green","red","grey","blue"),lty = c(1,1,1,1,2), cex = .5)
```

Scone: Filtering
===
class:small-code

```{r, eval=TRUE, echo=TRUE}
 # Simplify to a single logical
mfilt = !apply(simplify2array(mfilt[!is.na(mfilt)]),1,any)
```

Scone: Filtering
===
class:small-code

- Apply cell filtering and filter on highly expressed gene.

```{r, eval=TRUE, echo=TRUE}
# Cell filter
goodDat = fluidigm[,mfilt]

# Final Gene Filtering: Highly expressed in at least 5 cells
num_reads = quantile(assay(fluidigm)[assay(fluidigm) > 0])[4]
num_cells = 5
is_quality = rowSums(assay(fluidigm) >= num_reads ) >= num_cells
```

Scone: Workflows Inputs
===
class:small-code

```{r, eval=TRUE, echo=TRUE}
# Expression Data (Required)
expr = assay(goodDat)[is_quality,]

# Biological Origin - Variation to be preserved (Optional)
bio = factor(colData(goodDat)$Biological_Condition)
```

Scone: Workflows Inputs
===
class:small-code

```{r, eval=TRUE, echo=TRUE}
# Processed Alignment Metrics - Variation to be removed (Optional)
qc = colData(goodDat)[,metadata(goodDat)$which_qc]
ppq = scale(qc[,apply(qc,2,sd) > 0],center = TRUE,scale = TRUE)

# Positive Control Genes - Prior knowledge of DE (Optional)
poscon = intersect(rownames(expr),strsplit("ALS2, CDK5R1, CYFIP1, DPYSL5, FEZ1, FEZ2, MAPT, MDGA1, NRCAM, NRP1, NRXN1, OPHN1, OTX2, PARD6B, PPT1, ROBO1, ROBO2, RTN1, RTN4, SEMA4F, SIAH1, SLIT2, SMARCA1, THY1, TRAPPC4, UBB, YWHAG, YWHAH",split = ", ")[[1]])
```

Scone: Workflows Inputs
===
class:small-code

```{r, eval=TRUE, echo=TRUE}
# Negative Control Genes - Uniformly expressed transcripts (Optional)
negcon = intersect(rownames(expr),hk)
```

Scone: User Functions
===
class:small-code

- Total sum scaling

```{r, eval=TRUE, echo=TRUE}
SUM_FN = function (ei) 
{ # TSS
  sums = colSums(ei)
  eo = t(t(ei)*mean(sums)/sums)
  return(eo)
}
```

Scone: User Functions
===
class:small-code

- Similar to TSS but with complexity.

```{r, eval=TRUE, echo=TRUE}
EFF_FN = function (ei) 
{ # Divided by complexity
  sums = colSums(ei > 0)
  eo = t(t(ei)*sums/mean(sums))
  return(eo)
}
```

Scone: User Functions
===
class:small-code

```{r, eval=TRUE, echo=TRUE}
scaling=list(none=identity, #do nothing
             sum = SUM_FN,  # User functions
             eff = EFF_FN,
             tmm = TMM_FN, # SCONE
             uq = UQ_FN,
             uqp = UQ_FN_POS,
             fq = FQT_FN,
             fqp = FQ_FN_POS,
             deseq=DESEQ_FN,
             deseqp=DESEQ_FN_POS)
```

Scone: Imputation Settings
===
class:small-code

```{r, eval=TRUE, echo=TRUE}
# Simple FNR model estimation with SCONE::estimate_ziber
# fnr_out = estimate_ziber(x = expr, bulk_model = TRUE,
#                         pos_controls = rownames(expr) %in% hk,
#                         maxiter = 10000)
load("data/fnr_out.Robj")
```

Scone: Imputation Settings
===
class:small-code

```{r, eval=TRUE, echo=TRUE}
## ----- Imputation List Argument ----- 
imputation=list(none=impute_null, # No imputation
                expect=impute_expectation)
                # Replace zeroes with expected expression level
```

Scone: Imputation Settings
===
class:small-code

- Passed into functions in the imputation list.

```{r, eval=TRUE, echo=TRUE}
impute_args = list(p_nodrop = fnr_out$p_nodrop, mu = exp(fnr_out$Alpha[1,]))
```

Scone: Setting Up Params
===
class:small-code

```{r, eval=TRUE, echo=TRUE}
params <- scone(expr, 
                imputation = imputation, impute_args = impute_args,
                scaling=scaling, 
                qc=ppq, bio = bio,
                # Negative controls for RUVg
                # normalization and evaluation
                ruv_negcon = negcon,
                # Parameter Arguments
                k_qc=3, k_ruv = 3,
                adjust_bio="no", 
                run=FALSE)
```

Scone: Workflow Params
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
# Visualize output params object
head(params)
```

Scone: Workflow Params
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
apply(params,2,unique)
```

Scone: Updating for Imputation
===
class:small-code

- Removing some filtering for the imputed data.

```{r, eval=TRUE, echo=TRUE}
is_screened = ((params$imputation_method == "expect") & (params$scaling_method %in% c("none","deseqp","uqp","fqp","eff")))
params = params[!is_screened,]
```

Scone: Filtered Params
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
head(params)
```

Scone: Run!
===
class:small-code

```{r, eval=TRUE, echo=TRUE}
BiocParallel::register(BiocParallel::SerialParam())
res <- scone(expr, 
             imputation = imputation, impute_args = impute_args,
             scaling=scaling,
             qc=ppq, bio = bio,
             ruv_negcon = negcon,
             k_qc=3, k_ruv = 3, 
             adjust_bio="no", 
             eval_poscon = poscon, # Positive controls for evaluation
             run=TRUE, params = params, # Additional params
             eval_kclust = 2:6,stratified_pam = TRUE,
             return_norm = "in_memory",
             rezero = TRUE)
```

Scone: Output
===
class:small-code

- normalized_data: list of normalized expression data (log-scale).
- metrics: raw metrics for normalizations.
- scores: sorted priority of best workslows.

class:small-code

```{r, eval=TRUE, echo=TRUE}
names(res)
```

Scone: Biplot
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
#VIZ only
pc_obj = prcomp(apply(na.omit(t(res$scores[,-ncol(res$scores)])),1,rank),center = TRUE,scale = FALSE)
bp_obj = biplot_colored(pc_obj,y = -res$scores[,ncol(res$scores)],expand = .6)
points(t(bp_obj[1,]), pch = 1, col = "red", cex = 1)
points(t(bp_obj[1,]), pch = 1, col = "red", cex = 1.5)
points(t(bp_obj[rownames(bp_obj) == rownames(params)[1],]), pch = 1, col = "blue", cex = 1)
points(t(bp_obj[rownames(bp_obj) == rownames(params)[1],]), pch = 1, col = "blue", cex = 1.5)
arrows(bp_obj[rownames(bp_obj) == rownames(params)[1],][1],
       bp_obj[rownames(bp_obj) == rownames(params)[1],][2],
       bp_obj[1,][1],
       bp_obj[1,][2],
       lty = 2, lwd = 2)
```

Scone: Interactive!
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
sconeReport(scone_res = res,
            qc = ppq,
            bio = bio,
            negcon = negcon, poscon = poscon)
```

Scone: Tutorial
===

If you are interested in reading more about Scone feel free to visit [this tutorial](//github.com/YosefLab/scone/blob/develop/vignettes/sconeTutorial.Rmd).

Dimensionality reduction and plotting
===

![outlier_corgi](images/corgis/outlier_corgi.jpg)

Dimensionality Reduction and Ordination
===

- Start with many measurements (high dimensional).
  - Want to reduce to a few features (lower-dimensional space).
- One way is to extract features based on capturing groups of variance.
- Another could be to preferentially select some of the current features.
  - We have already done this.
- We need this to plot the cells in 2D (or ordinate them)
- In scRNA-Seq PC1 may be complexity.

PCA: in Quick Theory
===

- Eigenvectors of covariance matrix.
- Find orthogonal groups of variance.
- Given from most to least variance.
  - Components of variation.
  - Linear combinations explaining the variance.
  
---

![pca_describe](images/PCA_plot_02.gif)

PCA: in Quick Theory
===

http://setosa.io/ev/principal-component-analysis

PCA: in Practice
===

Things to be aware of.
- Data with different magnitudes will dominate.
  - Zero center and divided by SD.
  - (Standardized).
- Can be affected by outliers.

t-SNE: Nonlinear Dimensional Reduction
===

![tsne](images/cell_cycle_1.png)

t-SNE: Collapsing the Visualization to 2D
===

![tsne_collapsed](images/cell_cycle_collapse.png)

t-SNE: What and Why?
===

![tsne](images/tsne.png)

PCA and t-SNE Together
===

Often t-SNE is performed on PCA components
- Liberal number of components.
- Removes mild signal (assumption of noise).
- Faster, on less data but, hopefully the same signal.

Plotting Cells
===

![fancy](images/corgis/fancy.jpg)

Select Variable Genes
===
class:small-code

- We are going to focus on highly variable genes.
  - Average expression (X) and dispersion (SD)(Y).
  - Bins genes (20).
  - Z-score for dispersion.
- fxn.x and fxn.y allow one to change the measurements.
  - Cut.offs are high and low, X and Y.

```{r, eval=FALSE, echo=TRUE}
pbmc.seurat <- MeanVarPlot(pbmc.seurat,fxn.x=expMean,fxn.y=logVarDivMean,
                           x.low.cutoff=0.0125,x.high.cutoff=3,
                           y.cutoff=0.5,do.contour=FALSE,do.plot=FALSE)
```

Select Variable Genes
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
pbmc.seurat <- MeanVarPlot(pbmc.seurat,fxn.x=expMean,fxn.y=logVarDivMean,
                           x.low.cutoff=0.0125,x.high.cutoff=3,
                           y.cutoff=0.5,do.contour=FALSE,do.plot=FALSE)
```

Select Variable Genes
===

```{r, eval=TRUE, echo=TRUE}
length(pbmc.seurat@var.genes)
```

Seurat: Performing PCA
===
class:small-code

- Calculating PCA with the highly variable genes.   

```{r, eval=TRUE, echo=TRUE,fig.align="center"}
pbmc.seurat <- PCA(pbmc.seurat,pc.genes=pbmc.seurat@var.genes,do.print=FALSE)
```

Seurat: Performing PCA
===
class:small-code

```{r, eval=TRUE, echo=TRUE,tidy=TRUE,fig.align="center"}
# Calculate PCA projection
pbmc.seurat <- ProjectPCA(pbmc.seurat)

# Can plot top genes for top components
PrintPCA(pbmc.seurat,pcs.print=1:2,genes.print=5,use.full=TRUE)
```

Seurat: Performing PCA
===
class:small-code

```{r, eval=TRUE, echo=TRUE,tidy=TRUE,fig.align="center"}
# Calculate PCA projection
pbmc.seurat <- ProjectPCA(pbmc.seurat)
```

Seurat: Performing PCA
===
class:small-code

- Top 5 genes in the loading for PC1 and PC2.

```{r, eval=TRUE, echo=TRUE,tidy=TRUE,fig.align="center"}
# Can plot top genes for top components
PrintPCA(pbmc.seurat,pcs.print=1:2,genes.print=5,use.full=TRUE)
```

Seurat: PCA Visualizations
===
class:small-code

- Top 30 genes associated with the first two components.

```{r, eval=FALSE, echo=TRUE}
VizPCA(pbmc.seurat, pcs.use=1:2)
```

Seurat: PCA Visualizations
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
VizPCA(pbmc.seurat, pcs.use=1:2)
```

Seurat: Check your Batch Correction
===

How can we apply this?
- Can check components to see if gene show up that are enriched in components.
- Using the scores you can perform GE analysis to decribe the component.

Seurat: PCA Visualizations
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
PCAPlot(pbmc.seurat, 1, 2)
```

Seurat: PCA Visualizations
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
PCAPlot(pbmc.seurat, 1, 2)
```

Seurat: PCA Visualizations
===
class:small-code

- Plot top 30 genes in top 100 cells for PC1.

```{r, eval=FALSE, echo=TRUE}
PCHeatmap(pbmc.seurat, pc.use=1, cells.use=100, do.balanced=TRUE)
```

Seurat: PCA Visualizations
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
PCHeatmap(pbmc.seurat, pc.use=1, cells.use=100, do.balanced=TRUE)
```

Seurat: Choosing Components
===
class:small-code

```{r, eval=FALSE, echo=TRUE}
# Time Intensive
# Jackstraw
# pbmc.seurat <- JackStraw(pbmc.seurat, num.replicate = 100, do.print = FALSE)
```

Seurat: Choosing Components
===
class:small-code

How do we choose how many components to use?   
 - When there is diminishing returns to include it.
 - Selection is performed more liberally in our setting.

```{r, eval=FALSE, echo=TRUE}
# Scree (elbow) plot
PCElbowPlot(pbmc.seurat)
```

Seurat: Choosing Components
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
# Time Efficient but more ad hoc
# Scree (elbow) plot
PCElbowPlot(pbmc.seurat)
```

Seurat: Store Clusters
===
class:small-code

- Determine subclusters for the plot.
- Separate graph based approach.
   - is not aware of the t-SNE projection.
- Using PC 1-10

```{r, eval=TRUE, echo=TRUE}
# 1 minute
pbmc.seurat <- FindClusters(pbmc.seurat, pc.use = 1:10, resolution = 0.6, print.output = 0, save.SNN = TRUE)
```

Seurat: Run t-SNE
===
class:small-code

- Calculate and plot t-SNE on PC 1- 10.   
- Uses Barnes-hut implementation.

```{r, eval=FALSE, echo=TRUE}
# Calculate t-SNE Ordination
pbmc.seurat <- RunTSNE(pbmc.seurat, dims.use = 1:10, do.fast = TRUE)
# Plot
TSNEPlot(pbmc.seurat)
```

Seurat: Run t-SNE
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
pbmc.seurat <- RunTSNE(pbmc.seurat, dims.use = 1:10, do.fast = TRUE)
TSNEPlot(pbmc.seurat)
```

---

This is not PCA
- Distance is best understood in close neighbors.
- The measurement of distance is difficult to understand.

Seurat: Side by side
===
class:small-code

**PCA**  
```{r, eval=TRUE, echo=FALSE}
PCAPlot(pbmc.seurat, 1, 2)
```

---

**t-SNE**  
```{r,eval=TRUE, echo=FALSE,tidy=TRUE}
TSNEPlot(pbmc.seurat)
```

Seurat: Plotting Genes Through Clusters
===
class:small-code

Now that we have subclusters of cell populations plotting genes through subclusters is identical to before.
- Seurat stores and groups by subclusters automatically.

```{r, eval=FALSE, echo=TRUE}
VlnPlot(pbmc.seurat, c("MS4A1","CD79A"))
```

Seurat: Plotting Genes Through Clusters
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
VlnPlot(pbmc.seurat, c("MS4A1","CD79A"))
```

Seurat: Plotting Genes on Clusters
===
class:small-code

You can also gene expression through out the cell ordination.
- Marker genes can help identify cell groups.
- Metadata can help visualize batch affects.

```{r, eval=FALSE, echo=TRUE}
FeaturePlot(pbmc.seurat, c("MS4A1","CD3E", "GNLY", "FCER1A"), cols.use = c("grey","blue"))
```

Seurat: Plotting Genes on Clusters
===
class:small-code

```{r, eval=TRUE, echo=FALSE}
FeaturePlot(pbmc.seurat, c("MS4A1","CD3E", "GNLY", "FCER1A"), cols.use = c("grey","blue"))
```

Confirm Cell Identity
===
class:small-code

It is important to know cells are expressing expected genes.
- Many cell populations have known expressing genes.
- Many assays use sorting.
- Could have contaminants or unexpected diversity.

QC the Clusters!
===
class:small-code

```{r,eval=FALSE, echo=TRUE,tidy=FALSE}
FeaturePlot(pbmc.seurat, c("nGene"), cols.use = c("grey","blue"))
```

QC the Clusters!
===
class:small-code

```{r,eval=TRUE, echo=FALSE,tidy=FALSE}
FeaturePlot(pbmc.seurat, c("nGene"), cols.use = c("grey","blue"))
```

QC the Clusters!
===
class:small-code

Check for your batch affect.
- We are going to make a fake batch affect (site) and plot this as an example of how one can visualize unwanted signal.

```{r, eval=FALSE, echo=TRUE, tidy=FALSE}
# Making Fake Data
fake.sites <- as.integer(pbmc.seurat@ident %in% c(5,2,8,7))
names(fake.sites) <- colnames(pbmc.seurat@data)
# Add metadata
pbmc.seurat <- AddMetaData(pbmc.seurat, fake.sites, "site")
# Plot feature
FeaturePlot(pbmc.seurat, c("site"), cols.use = c("green","orange"))
```

QC the Clusters!
===
class:small-code

```{r, eval=TRUE, echo=FALSE, tidy=FALSE}
# Making Fake Data
fake.sites <- as.integer(pbmc.seurat@ident %in% c(5,2,8,7))
names(fake.sites) <- colnames(pbmc.seurat@data)
# Add metadata
pbmc.seurat <- AddMetaData(pbmc.seurat, fake.sites, "site")
# Plot feature
FeaturePlot(pbmc.seurat, c("site"), cols.use = c("orange","purple"))
```

Seurat: Getting your labels
===

```{r,eval=FALSE, echo=TRUE,tidy=FALSE}
cell.labels <- pbmc.seurat@ident
corner(cell.labels)
```

Seurat: Getting your labels
===

```{r,eval=TRUE, echo=FALSE,tidy=FALSE}
cell.labels <- pbmc.seurat@ident
corner(cell.labels)
```

Section Summary
===

- Dimensionality reduction help reduce data while *hopefully* keeping important signal.
  - t-SNE on PCA is often used in analysis
- Created several types of plot often seen in publications.
  - Plotting genes (through subgroups).
  - Ordinating cells in t-SNE space.
  - Heat maps of genes associated with PC components.
  - Plotting metadata on projects of data is an important QC tool.

Where are We at Now?
===

- Can plot genes vs genes, and throughout cells.
- Can plot cells.
- Can break plotted cells into subgroups.
  - These can become labels for later DE.
- Can plot across subgroups (maker genes).
- We can use plots of cells for batch affect visualization.

Differential Expression
===

![clump](images/corgis/corgi_clump.jpg)

Seurat: Differential Expression
===
class:small-code

- Default if one cluster again many tests.
  - Can specify an ident.2 test between clusters.
- Adding speed by exluding tests.
  - Min.pct - controls for sparsity
    - Min percentage in a group
  - Thresh.test - must have this difference in averages.

```{r,eval=FALSE, echo=TRUE,tidy=FALSE}
cluster1.markers <- FindMarkers(pbmc.seurat, ident.1 = 1, min.pct = 0.25)
head(cluster1.markers, 5)
```

Seurat: Differential Expression
===
class:small-code

- Find all cluster against all others.

```{r,eval=TRUE, echo=TRUE,tidy=FALSE}
pbmc.markers <- FindAllMarkers(pbmc.seurat, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
pbmc.markers %>% group_by(cluster) %>% top_n(2, avg_diff)
```

Seurat: DE Tests
===
class:small-code

**bimod:** Tests differences in mean and proportions.  
**roc:** Uses AUC like definition of separation.  
**t:** Student's T-test.  
**tobit:** Tobit regression on a smoothed data.  

Seurat: Plotting DE Genes
===
class:small-code

```{r,eval=FALSE, echo=TRUE,tidy=FALSE}
pbmc.markers %>% group_by(cluster) %>% top_n(10, avg_diff) -> top10
DoHeatmap(pbmc.seurat, genes.use = top10$gene, order.by.ident = TRUE, slim.col.label = TRUE, remove.key = TRUE)
```

Seurat: Plotting DE Genes
===
class:small-code

```{r,eval=TRUE, echo=TRUE,tidy=FALSE}
pbmc.markers %>% group_by(cluster) %>% top_n(10, avg_diff) -> top10
DoHeatmap(pbmc.seurat, genes.use = top10$gene, order.by.ident = TRUE, slim.col.label = TRUE, remove.key = TRUE)
```

SCDE: What is the Data?
===

- Data is from [Islam et al. 2011](http://genome.cshlp.org/content/21/7/1160.long)
- Approximately 100 samples.
  - Caution we use less...
- Mouse cells
  - Embryonic fibroblasts (MEF; control)
  - Embryonic stem cells (ES)

SCDE: Single Cell Differential Expression
===

![scde_intro](images/scde_intro.png)

SCDE: in Quick Theory
===

For each group (ES or MEF).
- Genes are modeled to have two groups of counts.
  - Noisy area highly prone to dropout (Poisson distribution).
  - "Amplified" signal (Negative Binomial distribution).
- This makes the error model to understand how much one can trust counts.
- Pairwise within groups.

Differential Expression.
- Expected value * the probability of dropout in that cell for that expression level.

SCDE: Load Data
===
class:small-code

- Pull in the data for the tutorial.
- In the future you would read in the data.
  - Read.table or load Seurat object.

```{r, eval=TRUE, echo=TRUE,tidy=FALSE}
data(es.mef.small)
```

SCDE: Filter
===
class:small-code

- Filter the noise.
  - Almost every package has a function for this.
  - Filtering on gene prevalence.

```{r, eval=TRUE, echo=TRUE,tidy=FALSE}
dim(es.mef.small)
cd <- clean.counts(es.mef.small, min.lib.size=1000, min.reads = 1, min.detected = 1)
dim(cd)
```

SCDE: Create Labels
===
class:small-code

- Let's labels for the two groups.

```{r,eval=TRUE, echo=TRUE,tidy=FALSE}
## Setting up cells groups
data.groups <- rep(NA, ncol(es.mef.small))
data.groups[ grep("MEF", names(es.mef.small)) ] <- "MEF"
data.groups[ grep("ESC", names(es.mef.small)) ] <- "ESC"
data.groups <- factor(data.groups, levels = c("ESC","MEF"))
names(data.groups) <- colnames(es.mef.small)
table(data.groups)
```

SCDE: Calculate Error Models
===
class:small-code

- Some steps in SCDE can be time intensive.   
  - For the tutorial we will read in the result of this step.

```{r, eval=TRUE, echo=TRUE,tidy=FALSE}
## Calculate error models
## Time Intensive step
# o.ifm <- scde.error.models(counts=cd, groups= data.groups, n.cores=4,
#                           threshold.segmentation=TRUE, save.crossfit.plots=FALSE,
#                           save.model.plots=FALSE, verbose=1)
## Precomputed
data(o.ifm)
```

SCDE: Calculate Error Models
===
class:small-code

- How do we speed this up?

```{r, eval=TRUE, echo=TRUE,tidy=FALSE}
## Calculate error models
## Time Intensive step
# o.ifm <- scde.error.models(counts=cd, groups= data.groups, n.cores=4,
#                           threshold.segmentation=TRUE, save.crossfit.plots=FALSE,
#                           save.model.plots=FALSE, verbose=1)
# Check number of cores
detectCores()
```

SCDE: Model Details
===
class:small-code

```{r, eval=FALSE, echo=TRUE,tidy=FALSE}
# Error model coefficients (cells = rows)
# corr.a = slope of the correlated component fit
# Negative corr.a could be bad cells
# corr.b intercept of the correlated component fit
# corr.theta is NB over-dispersion
# fail.r background poisson rate
head(o.ifm)
```

SCDE: Model Details
===
class:small-code

```{r, eval=TRUE, echo=FALSE,tidy=FALSE}
head(o.ifm)
```

SCDE: Filter Out Poor Fits
===
class:small-code

```{r, eval=TRUE, echo=TRUE,tidy=FALSE}
dim(o.ifm)
valid.cells <- o.ifm$corr.a > 0
table(valid.cells)
o.ifm <- o.ifm[valid.cells, ]
dim(o.ifm)
```

SCDE: Estimate a Prior to Start
===
class:small-code

- Bayesian technique
- Need a starting point or first good guess to start.   

```{r, eval=TRUE, echo=TRUE,tidy=FALSE}
## Calculate the Prior (starting value)
o.prior <- scde.expression.prior(models=o.ifm, counts=cd, length.out=400, show.plot=FALSE)
```

SCDE: Perform Differential Tests
===

- Why are we doing this again?

```{r, eval=TRUE, echo=TRUE, tidy=FALSE}
## Setting up cells groups
data.groups <- rep(NA, nrow(o.ifm))
data.groups[ grep("MEF", rownames(o.ifm)) ] <- "MEF"
data.groups[ grep("ESC", rownames(o.ifm)) ] <- "ESC"
data.groups <- factor(data.groups, levels = c("ESC","MEF"))
names(data.groups) <- row.names(o.ifm)

## Perform T-test like analysis
# 2 minutes on standard computer, 1 core
#ediff <- scde.expression.difference(o.ifm, cd, o.prior, groups=data.groups, n.randomizations=100, n.cores=2, verbose=1)
load("data/ediff.Robj")
```

Visualize Differentially Expressed Genes
===

- mle = log2 fold change (estimate).
- ub and lb = upper and lower bound on mle.
- ce = log2 fold change (conservative estimate).
- Z = Z-score .
- cZ = Z-score corrected for multiple hypothesis testing.

---

![scde_output](images/scde_output_2.png)

SCDE: Top Upregulated Genes
===

- What are the top upregulated genes?

```{r, eval=TRUE, echo=TRUE, tidy=FALSE}
head(ediff[order(ediff$Z, decreasing  =  TRUE), ])
```

SCDE: Write Data to Text File
===

- Save your data.   

```{r, eval=FALSE, echo=TRUE, tidy=FALSE}
write.table(ediff[order(abs(ediff$Z), decreasing = TRUE), ],
            file = "data/scde_results.txt", row.names = TRUE, col.names = TRUE, sep = "\t", quote = FALSE)
```

SCDE: Plot a Gene
===

- Let's look at our data.   

```{r, eval=FALSE, echo=TRUE, tidy=FALSE}
scde.test.gene.expression.difference("Tdh", models = o.ifm, counts = cd, prior = o.prior)
```

SCDE: Plot a Gene
===

```{r, eval=TRUE, echo=FALSE, tidy=FALSE}
scde.test.gene.expression.difference("Tdh", models = o.ifm, counts = cd, prior = o.prior)
```

SCDE: Interactive Exploration
===

- Interactive exploration.

```{r, eval=FALSE, echo=TRUE, tidy=FALSE}
# scde.browse.diffexp(ediff, o.ifm, cd, o.prior, groups = groups, name = "diffexp1", port = 1299)
```

SCDE and Batch Affects
===

- Create fake metadata.

```{r, eval=FALSE, echo=TRUE, tidy=FALSE}
batch <- as.factor(ifelse(rbinom(nrow(o.ifm), 1, 0.5) == 1, "batch1", "batch2"))
table(groups, batch)
```

SCDE and Batch Affects
===

```{r, eval=FALSE, echo=TRUE, tidy=FALSE}
scde.test.gene.expression.difference("Tdh", models = o.ifm, counts = cd, prior = o.prior, batch = batch)
```

SCDE and Batch Affects
===

- Here we correct initially instead of per gene.

```{r, eval=FALSE, echo=TRUE, tidy=FALSE}
ediff.batch <- scde.expression.difference(o.ifm, cd, o.prior, groups = groups, batch = batch, n.randomizations = 100, n.cores = 1, return.posteriors = TRUE, verbose = 1)
```

Pathway analysis
===

![saturation](images/corgis/corgi_saturation.jpg)

Pagoda
===

![pagoda_paper](images/pagoda_paper.png)

Pagoda: Overview Methodology
===

<div align="center">
<img src="images/pagoda_methodology.png" width=900>
</div>
Fan et al.

Pagoda: What is the Data?
===

- Data being used is [Pollen et al. 2014](//www.ncbi.nlm.nih.gov/pubmed/25086649)
- Approximately 300 samples.
  - We focus on 64 samples (human, cortex)
  - NPC - Neuronal Progenitor Cells
  - GW16 - Gestational week 16
  - GW21 - Gestational week 21
  - GW21+3 - Gestational week 21 + 3 weeks.

Pagoda: Load Data
===
class:small-code

```{r, eval=TRUE, echo=TRUE, tidy=TRUE}
data(pollen)
# Original genes and cells (count matrix)
dim(pollen)
# Filter poor cells
pollen.clean <- clean.counts(pollen)
# Cleaned matrix dimensions
dim(pollen.clean)
```

Pagoda: Create a Color Legend
===
class:small-code

```{r, eval=TRUE, echo=TRUE, tidy=TRUE}
name.keys <- gsub("^Hi_(.*)_.*", "\\1", colnames(pollen.clean))
name.keys
```

Pagoda: Create a Color Legend
===
class:small-code

```{r, eval=TRUE, echo=TRUE, tidy=TRUE}
l2cols <- c("coral4", "olivedrab3", "skyblue2", "slateblue3")[as.integer(factor(name.keys, levels = c("NPC", "GW16", "GW21", "GW21+3")))]
l2cols
```

Pagoda: Create Error Models
===
class:small-code

- This is a time intensive step.
- For now we are going to read in the data.

```{r, eval=TRUE, echo=TRUE, tidy=TRUE}
#knn <- knn.error.models(pollen.clean, k=ncol(pollen.clean)/4,
#                         n.cores=2, min.count.threshold=2,
#                         min.nonfailed=5, max.model.plots=10)
# Precomputed data
data(knn)
```

Pagoda: Normalize the Variance
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
#varinfo <- pagoda.varnorm(knn, counts=pollen.clean,
#                          trim=3/ncol(pollen.clean), max.adj.var=5,
#                          n.cores=1, plot=TRUE)
load("data/varinfo.Robj")

# list top overdispersed genes
sort(varinfo$arv, decreasing = TRUE)[1:10]
# Control for complexity
varinfo <- pagoda.subtract.aspect(varinfo, colSums(pollen.clean[, rownames(knn)]>0))
```

Pagoda: Normalize the Variance
===
class:small-code

```{r, eval=TRUE, echo=TRUE, tidy=TRUE}
#varinfo <- pagoda.varnorm(knn, counts=pollen.clean,
#                          trim=3/ncol(pollen.clean), max.adj.var=5,
#                          n.cores=2, plot=TRUE)
load("data/varinfo.Robj")
```

Pagoda: Normalize the Variance
===
class:small-code

<div align="center">
<img src="images/varinfo.png" width=800>
</div>

Pagoda: Normalize the Variance
===
class:small-code

```{r, eval=TRUE, echo=TRUE, tidy=TRUE}
# list top overdispersed genes
sort(varinfo$arv, decreasing = TRUE)[1:10]
# Control for complexity
varinfo <- pagoda.subtract.aspect(varinfo, colSums(pollen.clean[, rownames(knn)]>0))
```

Pagoda: Load Precomputed Gene Groups
===
class:small-code

- This analysis path relies on known gene groups.   

```{r, eval=TRUE, echo=TRUE, tidy=TRUE}
library(org.Hs.eg.db)
# translate gene names to ids
ids <- unlist(lapply(mget(rownames(pollen.clean), org.Hs.egALIAS2EG, ifnotfound = NA), function(x) x[1]))
rids <- names(ids); names(rids) <- ids 
```

Pagoda: Load Precomputed Gene Groups
===
class:small-code

```{r, eval=TRUE, echo=TRUE, tidy=TRUE}
# convert GO lists from ids to gene names
gos.interest <- unique(c(ls(org.Hs.egGO2ALLEGS)[1:100],"GO:0022008","GO:0048699", "GO:0000280", "GO:0007067")) 
go.env <- lapply(mget(gos.interest, org.Hs.egGO2ALLEGS), function(x) as.character(na.omit(rids[x]))) 
go.env <- clean.gos(go.env) # remove GOs with too few or too many genes
go.env <- list2env(go.env) # convert to an environment
```

Pagoda: Known Gene Groups Overdispersion
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
# pwpca <- pagoda.pathway.wPCA(varinfo, go.env, n.components = 1, n.cores = 1)
load("data/pwpca.Robj")
df <- pagoda.top.aspects(pwpca, return.table = TRUE, plot = TRUE, z.score = 1.96)
```

Pagoda: Known Gene Groups Overdispersion
===
class:small-code

```{r, eval=TRUE, echo=FALSE, tidy=TRUE}
# pwpca <- pagoda.pathway.wPCA(varinfo, go.env, n.components = 1, n.cores = 1)
load("data/pwpca.Robj")
df <- pagoda.top.aspects(pwpca, return.table = TRUE, plot = TRUE, z.score = 1.96)
```

Pagoda: Known Gene Groups Overdispersion
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
head(df)
```

Pagoda: Novel Gene Group Overdispersion
===
class:small-code

- Unsupervised path.   

```{r, eval=TRUE, echo=TRUE, tidy=TRUE}
# clpca <- pagoda.gene.clusters(varinfo, trim = 7.1/ncol(varinfo$mat), n.clusters = 50, n.cores = 1, plot = TRUE)
load("data/clpca.Robj")
```

Pagoda: Novel Gene Group Overdispersion
===
class:small-code

<div align="center">
<img src="images/clpca.png" width=500>
</div>

Pagoda: Novel Gene Group Overdispersion
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
df <- pagoda.top.aspects(pwpca, clpca, return.table = TRUE, plot = TRUE, z.score = 1.96)
```

Pagoda: Novel Gene Group Overdispersion
===
class:small-code

```{r, eval=TRUE, echo=FALSE, tidy=TRUE}
df <- pagoda.top.aspects(pwpca, clpca, return.table = TRUE, plot = TRUE, z.score = 1.96)
```

Pagoda: Novel Gene Group Overdispersion
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
head(df)
```

Pagoda: Novel Gene Group Overdispersion
===
class:small-code

```{r, eval=TRUE, echo=FALSE, tidy=TRUE}
head(df)
```

Pagoda: Cell Clustering
===
class:small-code

```{r, eval=TRUE, echo=TRUE, tidy=TRUE}
# Get full info on the top aspects
# tam <- pagoda.top.aspects(pwpca, clpca, n.cells = NULL, z.score = qnorm(0.01/2, lower.tail = FALSE))
load("data/tam.Robj")
# Determine overall cell clustering
hc <- pagoda.cluster.cells(tam, varinfo)
# tamr <- pagoda.reduce.loading.redundancy(tam, pwpca, clpca)
load("data/tamr.Robj")
# tamr2 <- pagoda.reduce.redundancy(tamr, distance.threshold = 0.9, plot = TRUE, cell.clustering = hc, labRow = NA, labCol = NA, box = TRUE, margins = c(0.5, 0.5), trim = 0)
load("data/tamr2.Robj")
col.cols <- rbind(groups = cutree(hc, 3))
```

Pagoda: Visualize Clustering
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
pagoda.view.aspects(tamr2, cell.clustering = hc, box = TRUE, labCol = NA, margins = c(0.5, 20), col.cols = rbind(l2cols))
```

Pagoda: Visualize Clustering
===
class:small-code

```{r, eval=TRUE, echo=FALSE, tidy=TRUE}
pagoda.view.aspects(tamr2, cell.clustering = hc, box = TRUE, labCol = NA, margins = c(0.5, 20), col.cols = rbind(l2cols))
```

Pagoda: Interactive Clustering
===
class:small-code

```{r, eval=FALSE, echo=TRUE, tidy=TRUE}
## compile a browsable app, showing top three clusters with the top color bar
# app <- make.pagoda.app(tamr2, tam, varinfo, go.env, pwpca, clpca, col.cols = col.cols, cell.clustering = hc, title = "NPCs")
## show app in the browser (port 1468)
# show.app(app, "pollen", browse = TRUE, port = 1468) 
```

Section Summary
===

- Generated groups of cells (labels) from subclusters.
- DE can be performed on cell subclusters.
  - Addresses the specific characteristics of the underlying data.
  - Is a t-test not an ANOVA
  - Can be time intensive.
- Pathway enrichment analysis can be performed using de novo and established gene groupings.

What Did We Miss? (So Much)
===

- Seurat
  - Data imputation, spatial inference, batch effect correction, ...
- SCDE
  - Batch Effect Correction, ...
- Pseudotemporal Analysis (time-series)
  - Monocle2, ...
- So many more tools are emerging, ...
-- https://github.com/seandavi/awesome-single-cell

What did we accomplish?
===

- Looked at the data and performed filtering and QC
- Plot genes and cells.
- Discovered subgroups of cells.
- Groups of cells were used as labels in DE.
- Groups of genes were analyzed for enrichment.

Thank You
===

- Aviv Regev
- Brian Haas
- Anindita Basu
- Asma Bankapur
- Chloe Villani
- Karthik Shekhar

---

- Matan Hofree
- Michel Cole
- Monika Kowalczyk
- Nir Yosef
- Regev Single Cell Working Group
- Today's Attendees

Questions?
===

![gradute corgi](images/corgis/graduate_corgi.jpg)

Notes: to Make a PDF
===
class:small-code

- Create a pdf file before you plot ( can plot multiple plots ).
- Close the plotting.

```{r,eval=FALSE,tidy=TRUE}
#pdf( "data/my_file.pdf", useDingbats = FALSE ) # Start pdf
#plot( 1:10, log(1:10 ) ) # plot in to the pdf file
#plot( seq(0,.9,.1), sin(0:9) ) # another plot for the pdf file
#dev.off() # Close pdf file ( very important )
```
